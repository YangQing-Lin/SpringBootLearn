### 核心概念

--------------

一个概念的提出必定是要解决某些特定的问题

##### 由问题产生解决方案的思想：

- 代码书写现状

  - **耦合度偏高**，例如一个类（业务层）里写了其他的对象（数据层）实现（new），比如这个其他是一个接口，那么这个接口更新后，该类也要重新写对象实现（new），紧接着可能由其他类也需要改变，源代码发生了改变，需要重新编译等，这需要一定成本

  - 如何解决呢，解决的思路油然而生：既然是该类写了其他的实现（new）导致耦合度偏高，那么就不写该对象实现(new)，但是这样会报异常（没有实现对象），现在又不想自己实现对象，又想要正常运行

    于是解决方案来了：**使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象**

  - **以上解决方案的思想就是IoC**，Inversion of Control 控制反转

    - **对象的创建控制权由程序转移到外部**，这种思想称之为**控制反转**
    - 其作用就是**解耦**

- ##### 业务层实现需要依赖于dao对象运行

  - **IoC容器也把ervice和dao的依赖也绑定了**
  - 在实现业务层代码时，直接将IoC容器里dao层的对象给service，这样业务层就可以正常运行了
  - 以上思想就是 **DI**（Dependency Injection）依赖注入

- 这样，程序既能正常运行，也可以解耦

--------------------------

##### IoC（Inversion of Control）控制反转

- 使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象**创建控制权**由程序转移到外部，此思想称为控制反转

- Spring技术对IoC思想进行了实现

  如何实现的呢？

  - Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的 **”外部“** 

  IoC容器管理了大量的对象

  - IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为**Bean**

##### DI（Dependency Injection）依赖注入

- 在IoC容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入
- 两个bean有关系才会被IoC容器绑定依赖关系
- 绑定关系之后，达到的效果：在拿service对象的时候，想用里面的dao，直接就有了dao对象

##### 以上两个思想的最终目标就是充分解耦

具体怎么做的呢

- 使用IoC容器管理bean（IoC思想）
- 在IoC容器内将有依赖关系的bean进行关系绑定（DI思想）

##### 最终效果：

- 使用对象时，不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系
- 也就是说该对象运行所依赖的所有东西全部做好了

---------------

##### 个人理解：

##### 问题：

​	在实现service层的类代码时，通常需要用dao层的接口，如果在service的源代码中直接实现了dao层接口的对象（new），将来如果该dao层的接口发生了改变，那么service层相关类的源代码也需要发生改变，与此相关的源代码可能也会发生改变，源代码发生了改变，就需要重新编译，这样带来的成本很大，同时代码的耦合性偏高

##### 提出解决方案：

​	既然在实现service层的类代码时，是因为实现dao层接口的对象导致了耦合性偏高，那么是否可以不在service层的类代码中实现dao层对象呢，但是如果这样做的话，编译会报异常（没有实现对象）

​	那么是否可以实现：不在service层实现dao层对象，且可以正常编译呢？

​	由此IoC思想就出现了，Inversion of Control 控制反转，使用对象时，将主动new产生对象转换为外部提供对象，将对象的创建控制权由程序转移到外部，这样在service需要使用dao层对象的时候，由IoC实现dao层对象的创建、初始化等一系列工作，然后交给service

​	那么又产生了一个问题：service的运行依赖于dao层的对象，如果另一个类需要使用service的对象，可以从IoC容器中拿，那么service的实现又依赖于dao层对象，但是并不知道是哪个dao层对象（虽然dao层对象也在IoC容器中）？

​	于是DI（dependency Injection）依赖注入思想出现了：在IoC容器中建议两个有关系的bean的依赖，这样在拿service对象（bean）时，与此有依赖关系的对象也会被拿出并使用，这样service可以正常被实现了

##### 结果：

充分解耦，且程序正常运行

