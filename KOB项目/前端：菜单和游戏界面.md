### 前端：菜单和游戏界面

2022/7/12

------------------

#### 导航栏（nav）：

- 大多数网站的导航栏是类似的

- 可以把导航栏专门提炼出来，在 vue 里创造一个组件（可以复用）

- 在 componets 中创建组件，命名必须有两个字母大写

- 每一个组件都由三个部分组成

  - html	写到 <template> 标签里
  - js         写到 <script> 标签里
  - css      写到 <style scoped> 标签里（加上 scoped 的作用是在这对标签里写的 css 会加一个随机字符串，使得这个样式不会影响到组件以外的部分）

- [Bootstrap](https://v5.bootcss.com/) 可以让程序员很轻松的拥有美工的能力（调包）

- 导航栏高亮，当前在哪个页面，其对应的按钮高亮

  - 取得当前在哪个页面
  - 实时返回当前 route 的内容

  ```html
   <script>
   import { useRoute } from 'vue-router'
   import { computed } from 'vue'
  
   export default {
      setup() {
          const route = useRoute();
          let route_name = computed(() => route.name)
          return {
              route_name
          }
      }
   }
   </script>
  ```

  

---------------------------------

#### 内容（content）：

- 区别每个网站的是内容区域

- 每个页面创建一个单独的组件（一般在 views 里创建），且因为每个页面可能还会有多个组件，所以每个模块在 views 里创建一个单独的文件夹管理

- 各个页面应有自己的主页面（索引），每个页面同样由（html，js，css）组成

  - PK 
    - 游戏区域，为了方便单独创建一个组件 PlayGround 来写
      - 板子
  - Record 
  - Ranklist
  - User Bots
  - 404 
    - NotFound

- 将每个页面的内容用一块区域框起来（card）在 Bootstrap 里找

  ```html
  <div class="container">
  	<div class="card">
  		<div class="card-body">
  			<slot>要填充的内容</slot>
  		</div>
  	</div>
  </div>
  ```

  因为每个页面都需要 card，所以是公共的部分，公共的部分可以作为一个组件

-----------------------------------------------

#### 实现内容跳转：

- 随着链接的变化，跳转到对应的页面

- 主页中 <router-view> 会自动根据网址变化

- 其变化方式在 router 文件夹的 index.js 中定义
- 输入网址后重定向到 pk 页面
- 输入不正确的链接，重定向到 404 页面
- 在导航栏中点击按钮，跳转到对应的界面
  - 前后端分离模式可以实现，点击后，不刷新（单页面的应用）
  - vue router组件提供了一个标签实现这个功能，即把 <a> 标签换成 <router-link> 标签

------------------

#### 游戏页面：

- ##### 地图

  - 中心对称
  - 周围一圈都是墙
  - 中间是空地，空地里会随机一些障碍物
  - 一方从左下角出发，一方从右上角出发
  - 保证左下角和右上角是连通的（不能把某一方困住）
  - 每次刷新可以得到新的地图

-----------------------------

#### 实现游戏操作：

- ##### 在游戏里，如何实现一个物体在 “动”

  - 每一次渲染的画面称为帧，每到下一帧时，下一帧就把上一帧覆盖掉
  - 假设地图 1 秒钟刷新 60 次，即 1 秒有 60 帧（1 秒刷新 60 张图片），那么就可以动态的计算出这个物体在每一帧里的位置是什么，然后把他渲染出来
  - 当每秒极速放映这 60 张图片时，就可以实现看到物体在 “动”

- **需要写一个基类**（AcGameObject.js）：每秒钟所有游戏对象刷新 60 次

  - 一般浏览器默认每秒钟刷新 60 次

  - 浏览器有```requestAnimationFrame()```函数，可以传一个函数，那么这个函数就会在下一帧浏览器渲染之前执行一遍，想要在每一帧都执行，则需要写成递归函数

    ```js
    const step = () => {
        requestAnimationFrame(step)
    }
    requestAnimationFrame(step)
    ```

  - 创建对象

    ```js
    constructor() {
    	AC_GAME_OBJECTS.push(this);
    	this.timedelta = 0; // 这一帧执行的时刻距离上一帧执行的时刻的时间间隔（速度）
    	this.has_called_start = false; // 记录有没有执行过 start 函数
    }
    ```

  - 部分操作是创建的时候执行一次，求坐标，初始化等

    ```js
    start() { // 只执行一次
    
    }
    ```

  - 每一帧执行一次，除了第一帧之外

    ```js
    update() { // 每一帧执行一次，除了第一帧之外
    
    }
    ```

  - 删除之前执行

    ```
    on_destroy() { // 删除之前执行
    
    }
    ```

  - 删除操作

    ```js
    destroy() { // 删除操作
        this.on_destroy();
        
    	for (let i in AC_GAME_OBJECTS) {
    		const obj = AC_GAME_OBJECTS[i];
    		if (obj == this) {
    			AC_GAME_OBJECTS.splice(i);
    			break;
    		}
    	}
    }
    ```


- ##### 实现游戏操作完整代码：

  ```js
  const AC_GAME_OBJECTS = [];
  
  export class AcGameObject {
      constructor() {
          AC_GAME_OBJECTS.push(this);
          this.timedelta = 0; // 这一帧执行的时刻和上一帧执行的时刻的间隔（物体移动的速度）
          this.has_called_start = false; // 记录有没有执行过 start 函数
      }
  
      start() { // 只执行一次
  
      }
  
      update() { // 每一帧执行一次，除了第一帧之外
  
      }
  
      on_destroy() { // 删除之前执行
  
      }
  
      destroy() { // 删除操作
          this.on_destroy();
  
          for (let i in AC_GAME_OBJECTS) {
              const obj = AC_GAME_OBJECTS[i];
              if (obj == this) {
                  AC_GAME_OBJECTS.splice(i);
                  break;
              }
          }
      }
  
  }
  
  
  let last_timestamp; // 上一次执行的时刻
  const step = timestamp => { // 每一帧都执行一遍，传入参数 timestamp 为当前执行的时刻
      for (let obj of AC_GAME_OBJECTS) {
          if (!obj.has_called_start) {
              obj.has_called_start = true;
              obj.start();
          } else {
              obj.timedelta = timestamp - last_timestamp;
              obj.update();
          }
      }
  
      last_timestamp = timestamp;
      requestAnimationFrame(step)
  }
  requestAnimationFrame(step)
  ```

--------------

#### 实现游戏对象

- 地图

  - 创造一个组件 GameMap.vue 和脚本

  - 在游戏区域（h * w）里找到一个最大的矩形（rows * cols）

    ```min{h / rows, w / cols}```即是每个小方格的长度

  - 由若干小格子组成，颜色深浅相间，左上角第一个是浅色，可以分为奇格和偶格

  - canvas坐标系：横着是 x，竖着是 y，与数组定义的坐标系相反

  - 地图的大小

    - 存在的问题：当地图的长宽都为偶数或者都为奇数时，则双方每一时刻走到的格子坐标都是相同的奇偶性，则可能会存在双方在同一时刻走到同一格子的情况，出现平局，这样对当前优势的一方不利，对游戏AI策略来说不是很好
    - 如何解决：调整地图大小，使得长宽拥有不一样的奇偶性，这样双方在每一时刻走到的格子的奇偶性都不一样，如此，就不会出现双方同一时刻走到同一格子的情况

- 墙，障碍物

  - 创造一个脚本 Wall.js
  - 在 GameMap.js 里创造障碍物
  - 四周由一圈墙组成
  - 内部的障碍物关于**中心对称**
  - 要求双方连通，这样才有博弈，flord-fill 算法判断连通性

--------------------------

#### 地图及障碍物不应在前端实现

- 匹配对战的时候，双方使用的地图及障碍物应保持一致，这样就产生了 “该由哪一方随机地图及障碍物” 的问题，不管哪一方随机，对另外一方都不公平不科学
- 解决方案：将生成地图及障碍物的逻辑移植到后端实现，则双方匹配成功之后，会在后端统一随机一个地图及障碍物，然后发给双方的前端
- 如此，前端就不具备任何逻辑，只是起演示动画作用

-----------------------------

##### 以上执行流程

以上都是前端内容，每次用户在刷新浏览器的时候，都会将前端代码加载出来，加载完，pk页面会随机一个游戏地图，**该地图每秒钟会刷新 60 次**（人眼看到的是不变的），游戏地图创建完成会在里面**创建障碍物**：先四周，再随机内部障碍物，随机之后，会判断地图是不是连通的（即左下角到右上角的连通性），如果不连通就重新创建一次。

-------------------------------

2022/7/15

#### 画蛇

- 两条蛇，一条起点在左下角，另一条起点在右上角

- 初始时，两条蛇都只有一个点

- 两条蛇会在同一时间变长
  
  - 人为规定：两条蛇前十步：每一步长度 + 1，之后：每三步长度 + 1
  
- 蛇其实是一堆格子的序列
  - 单独定义蛇的一个格子 Cell.js
  - 每个格子画一个圆
    - 圆的坐标：在格子坐标的基础上加上0.5
  
- 每条蛇也定义成一个对象 Snake.js
  
  - 蛇想要动，即每一帧都画出来，则应继承基类 AcGameObject.js
  
- 在 GameMap.js 里创建两条蛇

- 蛇的美化

  - 美化前是由多个圆圈组成的，一节一节

  - 美化方式：蛇的身体里**相邻两个格子**（圆圈）**覆盖**一个矩形，该矩形由两个圆的圆心距离作为长，半径之和作为宽，中心点为两个圆的外切点

  - 分为竖直方向和水平方向，竖直方向需要考虑 y 方向矩形的变化，水平方向需要考虑 x 方向矩形的变化（因为是每一帧渲染一次）

  - 蛇的瘦身

    L * 0.8，往里缩了20%，需要在另一边补10%
    
  - 画蛇点睛
  
    - 事实上是画两个小圆
    - 蛇眼的位置与蛇头的朝向相关，随着蛇头方向的更新，蛇眼的位置也在变化
    - 为不同方向蛇眼的偏移量（相对于圆心的偏移量）打个表，渲染时查表即可

#### 坐标存的都是相对距离，渲染时要变成绝对距离

----------------------------

#### 蛇的操作

- ##### 蛇头的移动

  - 定义一个速度，每一帧执行一次 update_move()，并渲染 render() 出来，这样人眼看到的就是在移动

- 蛇整个序列的移动

  - 如果模仿物理环境里的移动，即蛇的身体中每一个格子都移动，这样会出现拐角处畸形的情况

  - 解决方案：**只移动蛇头和蛇尾**，中间部分不动

    - 创建一个新的蛇头，新蛇头向目的地移动
    - 蛇尾向下一个位置移动

  - 蛇什么时候可以动

    - 回合制游戏，双方都有输入，即同时获取了双方的下一步操作之后才会移动

    - 双方都发出了指令时，才会按照双方的指令分别将双方移动到各自的目的地

  - 判断蛇能不能动

    - 不能由每条蛇自己判断，运动员是不能当裁判的
    - 将裁判的逻辑放到 GameMap.js 里

  - 蛇的变长

    - 记录回合数

    - 前十回合：每一回合长度 + 1，之后：每三回合长度 + 1

- 获取完用户的操作之后，让蛇移动

  - 让蛇的身体的每一个格子都移动到下一个格子，且原身体不变，这样就实现了蛇头的复制

  - 移动蛇头到目标格子 update_move()

    - 每两帧之间移动的距离```move_distance = this.speed * this.timedelta / 1000;``` 

      速度乘以时间，timedelta 的单位是毫秒，需要 / 1000

    - 将获取到的距离加到坐标上，计算偏移量
    
  - 设置误差 eps，当两点的距离小于误差，就认为两点已经重合了
  
- ##### 蛇尾的移动

  - 判断一下当前要不要动蛇尾

    蛇尾的移动与蛇的长度有关，蛇的长度的变化与当前回合数有关

    蛇需要变长时蛇尾不变，不需要变长时，蛇尾需要走到下一个目的地，并砍掉原先的蛇尾

--------------------------

#### 获取用户的操作

- 从前端获取操作（后期移植到后端）
- 让用户从键盘输入操作
  - wdsa 控制第一条蛇的上右下左
  - 方向键控制第二条蛇的上右下左
- canvas 获取用户操作，在<canvas>标签里加入属性 tabindex="0"
- 给 canvas 绑定一个获取用户操作信息的事件 add_listening_events()
- 因为用户操作不一样一定从前端获取，也可以从后端获取，所以为了方便起见，写一个统一的接口来设置方向

----------------------

#### 裁判逻辑

检测某个格子是否合法 check_valid()：没有撞到两条蛇的身体和障碍物

- 枚举障碍物
- 枚举每条蛇的身体的格子，特判：当蛇的长度不会增加，蛇尾会前进的时候，不用判断蛇尾

蛇在更新下一步的操作的时候，如果目的位置不合法，该蛇就瞬间去世

##### 去世的状态需要具象化

- 当蛇的状态是 “die”，填充颜色变成惨白，且不能进行下一回合的操作

