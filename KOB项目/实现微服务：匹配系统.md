## 实现微服务：匹配系统

2022/8/12

-------------------

#### 匹配系统的流程

当两个用户都打开对战界面匹配的时候，各自向服务器端发送一个请求，匹配过程一般会持续十几秒，因此这是个异步的过程

当服务器端接受到前端匹配游戏的请求后，由于整个过程是一个异步的过程，等待的时间是未知的，一般这种异步的过程或者计算量比较大的过程，会用一个额外的服务去操作

这里写一个专门的匹配系统：**Matching System**，这是一个另外的程序或进程，维护了一堆用户的集合，**微服务**

当服务器端接受到前端匹配游戏的请求之后，就会将这个请求发送到匹配系统，更多的请求也都会通过服务器端发送到匹配系统，则匹配系统里会有很多待匹配游戏的用户

同时匹配系统会不断的进行匹配，随着时间的推移，将当前维护的这些用户里战斗力最接近的匹配成一组，当两个用户匹配成一组之后，匹配系统就会将结果返回给服务器端，服务器端又会将结果分别返回给两个用户的前端，之后两个用户就可以在前端看到当前返回的对手是谁，**同时在服务器端创建一个游戏的过程（Game）**

因为整个过程是一个异步的过程，匹配成功的时间是未知的，当得到结果之后需要将其立即返回给前端

鉴于此，服务器端需要使用**Websocket**协议，通过这个协议，不仅客户端可以主动向服务器端发送请求，服务器端也可以主动向客户端发送请求，全双工的通信方式

--------------------------------------------------------

#### **Websocket**协议的基本原理

将前端建立的每一个**Websocket**连接在后端维护起来，整个连接就是一个`WebSocketServer`类，每有一个连接就是`new`一个该类的实例，因此每一个连接在后端都是用这样的一个实例维护，所有和该连接相关的信息都会存到对应的实例里面（独有信息存为私有变量）

多线程，每有一个连接，都会开一个新的线程来维护

---------------------

#### 将整个游戏的过程都放到服务器端完成

##### 构思

##### 服务器端应该有一个单独的任务（Game）

1. **Create Map** 为匹配成功的双方生成一个唯一的地图

2. 将这个地图传给对战双方的客户端

3. **Waiting** 等待用户的输入，等待使用一个死循环`sleep`实现，并且设置等待时间，如果超时输入就判定lose，游戏结束，并返回游戏结果
   
   1. 客户端传来的输入（真人操作），读入键盘操作
   2. 接收`Bot`代码的输入，**微服务**
   
4. **Judge** 获取到输入之后，会将输入发送到该评测系统，判断两名玩家的下一步的走法是否合法，如果有一方的指令不合法，就表示这一方蛇原地去世，游戏结束，返回结果

   如果双方的走法都合法，游戏没有结束，就会循环 **Waiting** + **Judge**，直到游戏结束

经过上述分析，发现Game是一个独立的流程，且每局游戏都有一个单独的Game

所以**Game不能作为单线程来处理**

##### Game需要另起一个新的线程来做

每有一局对局，就要开一个线程进行游戏

##### 在Game里，**Waiting**，**Judge**和**Result**是一个线程，获取用户操作是一个线程

##### 保证双方对战的地图一致

当一组用户匹配成功之后，该任务需要为这组用户双方统一的生成当前对局的唯一的地图

##### 裁判机制

服务器端判定完游戏结果之后，再将结果返回给前端，前端只是用来画个画，不做任何判定逻辑

##### 双方蛇的移动

------------------

#### 集成`WebSocket`

<a href="https://mvnrepository.com/">Maven仓库</a>

WebSocket不是单例模式

##### 在`pom.xml`文件中添加依赖：

- `spring-boot-starter-websocket`
- `fastjson`，前后端通信

##### 添加`config.WebSocketConfig`配置类

##### 添加`consumer.WebSocketServer`类

自己实现后端向前端发送信息，异步通信过程，需要加一个锁

将连接对应的用户信息维护起来

用线程安全的哈希表维护所有的连接，key = 用户id，value = 用户id对应的连接

特殊注入`UserMapper`

##### 配置`config.SecurityConfig`

将`WebSocket`的链接放行

##### 在前端代码里调试

在store里存socket，在pk界面调试

##### 使用`JWT`验证

-----------------------

#### 实现前端界面

##### 创建匹配界面（matchground）

参考ac saber

grid布局

##### 利用`store`里存的`status`（matching / playing）切换页面

---------------

#### 调试匹配逻辑

##### 初步实现匹配过程（无Matching System）

点击开始匹配按钮就会向后端（WebSocket）发送一个请求，后端接收到该请求后，就会将该用户放到匹配池（内存）里，匹配池里人数过2，就会将这两个用户匹配成一组返回给后端，后端返回给用户

修改store里存的内容实现前端内容的改变

匹配池使用线程安全的`set`维护

##### 前后端通过`JSON`通信

--------------

#### 实现`Game`管理游戏流程

##### 在云端生成地图

对照前端生成地图的代码

----------------------

2022/8/13

### 完善服务器端Game类

##### 同步玩家的初始位置

- 存储玩家的id和位置，创建player类维护

  Player类需要维护蛇的id，起始位置，每一回合的指令（以此得知蛇的路径）

##### 同步游戏状态

一共有三个游戏地图，用户1和用户2的`client`端各一个，服务器端一个

现在需要将三个游戏地图的状态（蛇的移动等）同步

具体的流程：当某一条蛇移动了，其对应的`client`端会向服务器端发送一个消息表示该蛇的移动，当服务器接收到双方的蛇移动的消息之后，服务器端就会将两条蛇移动的信息分别返回给`client1`和`client2` 

-----------------------------------

### Game多线程之间的通信和加锁

##### 将Game变成一个支持多线程的类

继承Tread

##### 重写线程入口函数`run()`，该函数里会执行一回合一回合等待下一步操作的操作

设置变量`status`表示当前的游戏状态，“playing”表示正在游戏中，“finished”表示游戏结束

设置变量`loser`表示游戏结果，“all”表示平局，“A”表示A输了，“B”表示B输了

这里只是通过判断是否获取到了双方的输入决定游戏的结果

这里有一个**边界问题**：在超时的边界读入了某一方或者双方的输入。该问题可以忽略，在超时的边界读入输入可以判定为超时，这是合理的

游戏结束后，给双方发送游戏结果`sendResult()` 

##### 如果接收到了双方的输入，`judge()`

- 双方输入操作都合法，服务器向双方广播移动信息，以达到同步地图状态的操作
- 有不合法的操作，游戏结束，向双方广播游戏结果

##### 辅助函数`nextStep()`等待两名玩家的下一步操作

等待两名玩家输入，当两名玩家都输入之后，就进行下一步

如果超过一定时间之后，其中有一名玩家还没有输入的话，就结束操作，同时告诉是哪名玩家没有输入，即败方

上述操作可以借助**sleep**函数

##### 辅助函数`setNextStepA()` 和 `setNextStepB()` 修改下一步的操作

设置变量`nextStepA`和`nextStepB`分别表示`A`和`B`的下一步操作

#### :star:两个线程同时读写一个变量

对于**获取用户操作**的线程，在获取到双方的输入操作后，会通过上述辅助函数修改双方下一步的操作

对于**Waiting**，**Judge**和**Result**的线程，会读取下一步的操作

##### 两个线程会同时读写同一个变量，这样就会产生读写冲突

此时需要**加锁**解决读写冲突

-----------

#### 游戏进程中前后端通信

当通过键盘wsad操作蛇的时候，应该从前端向后端发送一条移动指令，移动当前自己的蛇

后端接收到移动指令后，会判断用户的蛇是哪一条，然后更新变量`nextStepA`或`nextStepB`

如果接收到了双方的下一步操作，就会进入评测

- 如果双方都合法，后端向前端发送消息，在前端渲染双方的下一步操作，以达到同步，并等待前端发送下一步操作，以此循环

- 如果有不合法的操作，游戏结束，后端向前端发送消息，表示游戏结束和结果

在后端判断蛇是否去世，使用变量`loser`判断

-------

#### Judge评判

##### 因为蛇的身体很短，所以每一回合都计算一下蛇的身体有哪些格子

创建一个辅助类`cell`，标记蛇的身体的每个单元

在player类里写一个辅助函数`getCells()`，获取蛇的身体

在player类里写一个辅助函数`check_tail_increasing()`，判断蛇的身体在什么时候变长

##### 判断两条蛇有没有重合

辅助函数`check_valid()`，判断双方最后一个单元（最新一次操作）的合法性

##### 判断游戏的状态（playing / finished）

-----------

#### 创建前端ResultBoard界面

写逻辑的时候，比较当前userid和蛇对应的用户id需要强制类型转换，因为一个是字符串一个是数字

----------------------

#### 数据库

record表用来存储对局记录

##### 表中的列：

- `id: int`，对局记录的id
- `a_id: int`
- `a_sx: int`
- `a_sy: int`
- `b_id: int`
- `b_sx: int`
- `b_sy: int`
- `a_steps: varchar(1000)`，a 的每回合走法
- `b_steps: varchar(1000)`，b 的每回合走法
- `map: varchar(1000)`，地图信息（障碍物等）
- `loser: varchar(10)`
- `createtime: datetime`

##### 创建数据库的pojo

数据库里名称用了下划线，pojo里对应的需要用驼峰命名

##### 创建Mapper

`extends BaseMapper<Record>`

##### 在对局结束之后，向前端发送结果之前，将该局记录信息存到数据库里

`saveToDatabase()`，对应的类型转换需创建并使用辅助函数

----------------

2022/8/20

### 实现匹配系统的微服务

##### 概要

当**WebSocket Server**接收到玩家匹配游戏的请求和信息之后，会向匹配系统的微服务**Matching Server**发送一个**http**的请求，**Matching**接收到之后，会单独开一个线程**Matching**处理这个匹配（类似`Game`）

**Mathcing**每隔一秒钟会扫描当前（匹配池的）已有的所有玩家，判断一下这些玩家能不能匹配成功，如果可以匹配成功就把结果返回，返回结果也是通过**http**

微服务实现用**SpringCloud** 

--------------------------------------------

#### 创建父级项目SpringCloud承载**Web后端**和**Matching Server** 

父级项目没有逻辑，把src目录删掉

添加依赖`spring-cloud-dependencies`，[Maven仓库地址]([Maven Repository: Search/Browse/Explore (mvnrepository.com)](https://mvnrepository.com/))

#### 创建SpringCloud的子项目——MatchingSystem

**MatchingSystem**本质上也是**SpringBoot**，因此需要添加相关依赖

#### 实现MatchingSystem

##### 配置相关端口

##### 实现接口MatchingService

- `addPlayer()`
- `removePlayer()`

##### 添加MatchingController

加入参数需要使用`MultiValueMap<>`，允许每个key对应一个链表value

##### 链接权限控制

只能通过**Web后端**访问

在**MatchingSystem**添加**SpringSecurity**的依赖

通过ip地址判断

设置该项目入口

#### 创建SpringCloud的子项目——Backend

#### 对接服务

之前为了调试，在Web端使用傻瓜式的匹配系统，现在要正式对接到**MatchingSystem**

##### 将之前傻瓜式的匹配系统的匹配逻辑封装成一个函数

##### 删掉Matchingpoor

-------------------------

#### 向**MatchingSystem**发送请求

请求匹配，匹配成功后再发请求，请求停止匹配

##### 配置工具**RestTemplate ** 

该工具可以在两个**SpringBoot**间进行通信

##### 修改数据库

将**bot**的**rating**放到**user**上

对应的修改**pojo**

修改相关的构造函数

##### 发送请求

通过**RestTemplate**在**startMatching**和**stopMatching**向**MatchingSystem**发送请求

---------------------------

#### 实现MatchingSystem收到请求后

**MatchingSystem**里会开一个匹配池（数组），当收到匹配的请求之后，会开一个**新线程**，每隔一秒钟扫描一遍**新数组**，将匹配池中**rating**相近的用户匹配到一起，随着时间的推移，**两名玩家的rating分差允许越来越大**

##### 创建一个包维护匹配线程

- MatchingPool

  继承**Thread** 

  重写**run**方法

  **players**，匹配池，**匹配线程和传入参数的线程共用**，涉及到读写冲突的问题，加锁解决

  addPlayer，加锁

  removePlayer，加锁

- Player

  userId, rating, waitingTime

##### 添加依赖lombok

构造函数的注解

##### 实现线程逻辑

死循环

sleep

每隔一段时间，扫描匹配池检查有没有匹配成功（辅助函数**matchPlayers**），匹配成功就停止并返回结果（辅助函数**sendResult**），没有匹配成功就继续循环（辅助函数**checkMatched**）

每名玩家每等待一秒，**waitingTime**就加1（辅助函数**increaseWaitingTime**），匹配的阈值就会变宽

对于**matchPlayers**，为了用户体验，等待时间越长的玩家会优先匹配

对于**checkMatched**，使用双方都能接受的策略

##### 在Web后端接收匹配成功信息

StartGameService

##### 防止报异常

当匹配池里的某个玩家断开连接（Alt + F4）