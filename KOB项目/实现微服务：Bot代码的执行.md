## 实现微服务：Bot代码的执行

2022/8/24

-----------------

#### 概要

代码执行的微服务是负责接收一段代码，并将代码扔到队列当中，每一次运行这段代码，运行完毕之后将结果返回给服务器

------------

### 创建SpringCloud的子项目 BotRunningSystem

##### 复制matchingsystem的依赖

##### 在BotRunningSystem项目中添加依赖：

[Maven仓库](https://mvnrepository.com/)

- `joor-java-8`，动态编译java代码

#### 创建BotRunningSystem的API

##### service，impl

##### controller

#### 相关配置

复制matchingsystem

##### 网关

##### restemplate

##### 修改端口号

--------------

### 修改前端，传入对Bot的选择操作

##### 匹配的时候可以选择人出战还是bot出战

选择框

##### 获取当前选择的bot_id

--------------

#### 通信的时候加上bot_id

**client**端向**web后端**发送消息时候

**web后端**向**matchingsystem**发送匹配信息的时候

匹配成功之后**matchingsystem**向**web后端**返回结果的时候

---------------

#### web通过matchingsystem传来的bot_id在数据库里获取对应的代码

##### mapper

通过bot_id在数据库里找到对应bot信息，传给**Game**，如果通过代码操作蛇，就要获取代码

------------

#### 等待玩家输入的时候（next step）

判断当前控制蛇的是人还是代码

##### 如果是代码的话，就要向**BotRunningSystem**发送这段代码

- restemplate
- input是当前局面
- 为防止混乱，将人的操作屏蔽掉

##### 如果是人操作的话，就要等待用户输入

-----------------------------

### 实现BotRunningSystem微服务

不断的接收用户的输入

将接收到的代码放到一个队列里面

:star:**生产者消费者模型**

用一个队列存储当前所有的任务，生产者发送一个任务过来，就把它存到队列里，消费者是一个单独的线程（苦力），不停的等待新的任务过来，每完成一个任务，就会检查队列是否为空，如果发现队列不为空，就从队头拿出一个任务去完成，完成之后再检查队列是否为空，如果不是空的，再从队头拿一个任务完成，以此往复

此循环使用条件变量**Condition**实现，如果队列为空消费者线程阻塞，反之消费者线程唤醒

#### 实现消费者BotPool线程

##### 当前线程不断消耗队列里的任务，生产者线程不断向队列里加任务

两个线程涉及到读写冲突，涉及队列操作时需要**加锁**

##### 如果队列为空

阻塞当前线程，`condition.await();`，默认锁释放

如果报异常，要解锁

##### 如果队列不会空

拿出队头任务并解锁

消耗该任务（编译代码）

先解锁再消耗，因为编译很慢

#### 实现consume编译

防止代码死循环，开一个新线程执行代码，线程可以控制执行时间

利用**joor-java-8**工具动态编译代码

-----------------

#### 编译完成之后将结果返回给web后端

##### 在web后端里实现一个新的API，用来接收结果

- service
- controller

##### restemplate

发送给后端

---------

#### 编写一个简单的AI





